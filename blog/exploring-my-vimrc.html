<!DOCTYPE html><html lang=en> <head><meta charset=UTF-8><meta name=viewport content="width=device-width, height=device-height, user-scalable=yes, initial-scale=1.0"><meta property=og:title content="gregsite - Exploring my vimrc"><meta property=og:type content=website><meta property=og:url content=https://gregdan3.github.io/blog/exploring-my-vimrc.html><meta property=og:image content=/avatar.jpg><meta property=og:locale content=en_US><meta property=og:site_name content=gregdan3><meta property=og:description content="gregdan3's personal website"><title>gregsite - Exploring my vimrc</title><link href=https://gregdan3.github.io/ rel=canonical><link href=/style.css rel=stylesheet type=text/css><link href=./style.css rel=stylesheet type=text/css><link href=/favicon.ico rel=icon type=image/png></head> <body> <header> <a href=/ style="border-bottom: none"><img src=/avatar.jpg alt="gregdan3's avatar"></a> <h2><a href=/ >gregdan3</a></h2> <h3>Exploring my vimrc</h3> </header> <nav> <a href=/ >Home</a> <a href=/blog/ >Blogzone</a> <a href=/toki-pona/ >Toki Pona</a> </nav> <article><p>This isn&rsquo;t my current vimrc on display. New version when?</p> <p>I&rsquo;ve been using vim as my primary editor for the better part of two years now. <a href=https://github.com/gregdan3/dotfiles/blob/master/.vimrc>My .vimrc</a> has gone through a great many changes in that time, but I think I hit a point early on where many of the features and plugins I had chosen were set in stone. It won&rsquo;t be a perfect fit for everyone, but you might find some useful pieces and ideas for your .vimrc.</p> <p>This is not so much a guide to setting up vim for first time use, as it is a place to explore options and features you may not already be aware of as a newer but experienced user.</p> <a name=What-I-care-about-in-my-vimrc></a> <h3>What I care about in my vimrc</h3> <p>I value the responsiveness of vim over nearly any other feature. Even in the context of a remote session, I can barely notice the delay in operations which is caused by the network. This is something vim accomplishes without help from the user doing any configuration, but it can be difficult to maintain if you are intent on adding many different plugins for different purposes.</p> <a name=Basic-features-of-my-vimrc></a> <h3>Basic features of my vimrc</h3> <p>When I first started using vim, I made a rule for myself to enter settings which I understand, rather than throwing others' config options into it and rolling with those changes, whatever they may be. This wasn&rsquo;t a perfect system, since there is always a point where you have to learn through experimentation and just throw settings into the config to see what suits you. Generally, though, I made sure to understand any setting I used so I could document it for myself, who might not know what I was thinking a year ago or more.</p> <p>In my vimrc, I try to group settings together by their family of functionality. Settings that change visual aspects of vim, but not the buffer, are grouped. Settings that exclusively affect the buffer are grouped.</p> <a name=Visual-Settings></a> <h4>Visual Settings</h4> <p>Visual settings I have enabled include setting the display to include the lastline, which is not clear just from reading <code>set display+=lastline</code>. Have you ever opened a file where a large amount of the content is on a single line? In this context, the default behavior is to obscure lines which leave the visible buffer with <code>@</code>. With <code>display+=lastline</code>, vim will no longer obscure this last line, meaning you&rsquo;ll always be able to see lines that exit the visible buffer.</p> <p>I also set <code>scrolloff=3</code> and <code>sidescrolloff=5</code> so that if you attempt to scroll the cursor outside the visible buffer, there will always be no less than three visible lines above or below the cursor and five visible lines to either side of the cursor. This forces the cursor to always be more central to the visual buffer, which is nice for relaxing your eyes into a single position.</p> <a name=Functional-settings></a> <h4>Functional settings</h4> <p>Most importantly, I <code>set undofile</code> and create a place to store undo history in <code>~/.vim/undodir</code>. I actually ensured this file exists (by creating it if it does not exist) at the top of my vimrc, so that this is less likely to fail. The importance of an undo file is to store file changes across sessions, so that if I open the same file again later, I can still undo/redo any and all remembered changes. The most common use case is that I close a file for a moment, such as by accident, and then re-open it. Normally, my write history would be lost, which may be inconvenient at best, and problematic at worst. With this, I don&rsquo;t need to worry; the change history is preserved.</p> <p>For convenience, I make it possible to use backspace across indents and ends of lines with <code>backspace=indent,eol,start</code>.</p> <p>Due to my familiarity with <a href=https://i3wm.org/ >i3wm</a>, I changed vim&rsquo;s default splitting behavior with <code>set splitbelow</code> and <code>set splitright</code>. This changes <code>:split</code> and <code>:vsplit</code>, respectively, to open into the specified direction. This is essentially just to mock i3&rsquo;s behavior.</p> <a name=Formatting-settings></a> <h4>Formatting settings</h4> <p>Most importantly, I make sure that vim automatically wraps the lines of the buffer (NOT the display!) at column 80. This is a change I made fairly recently, but since 80 column terminal widths were standard <a href=https://softwareengineering.stackexchange.com/questions/148677>a long time ago</a>, an 80 column width for text buffers actually makes much of my work more comfortable. For example, this is near perfectly enough text width to make a terminal taking up the left or right half of my screen (tiled via i3) also have text which takes up most of its width. Additionally, as noted in the above link, code which takes up a lot of width on the screen is that much harder to read and understand. This is accomplished with <code>set textwidth=80</code>, which cares about the width of lines in the buffer. If you use a tiling window manager, beware of <code>wrapmargin</code>, which cares about the visual width of the terminal! This becomes particularly frustrating when I collapse a vim window to half its previous width, and lines now change where they end as I type. To really make this option come alive, do <code>set formatoptions+=tc</code> to automatically apply this setting as you type. The <code>t</code> is the actual automation of this process; the <code>c</code> is for automatically inserting comment characters if this jump occurs while you&rsquo;re typing a comment in some code buffer.</p> <p>As I&rsquo;ve most often seen done by other developers, I make sure to never use tab characters, instead always filling in with four spaces.</p> <a name=Information-settings></a> <h4>Information settings</h4> <p>Setting the ruler is critical, to make vim&rsquo;s language-like controls come alive. I use <code>set number</code> and <code>set relativenumber</code> both, which show the current line number in the buffer on the cursor&rsquo;s line, and otherwise show the number of lines above and below the cursor on every other line.</p> <p>Also important is <code>set wildmenu</code>, to enable <code>:</code> command autocompletion, and <code>set wildmode=longest:full,list</code> so that you can see all the matches which are available to you.</p> <a name=Keybinds></a> <h4>Keybinds</h4> <p>I rebind <code>ctrl+H</code> to <code>ctrl+W, ctrl+H</code>, and do the same for the other three navigational keys, in order to save two keypresses when switching between buffers open in splits.</p> <a name=Autocommands></a> <h4>Autocommands</h4> <p>I stole my augroup for remembering the last position in a previously opened file from <a href=https://vi.stackexchange.com/questions/17007>here</a>. There&rsquo;s not much to say about this; it&rsquo;s a convenience option which vim doesn&rsquo;t natively provide the capability to do, but it is convenient none the less.</p> <p>I also clean all whitespace out at the end of lines in every buffer. Thus far, I haven&rsquo;t needed to work in a filetype for which this is a problem, but I&rsquo;m sure they exist. Until then, this setting stays.</p> <a name=My-thoughts-on-Plugins></a> <h3>My thoughts on Plugins</h3> <p>I&rsquo;ve seen a number of vim users out there decry the use of plugins for various reasons, among them the thought of &ldquo;You can do that without a plugin!&rdquo;. And for the most part, that is true; vim-airline, for example, can be replaced very cleanly with <a href=https://shapeshed.com/vim-statuslines/ >some effort</a> to create your own status bar.</p> <p>In my view, the purpose of a plugin should be to help the user to do something they already want, without that user needing to spend excessive time to think about and configure vim to do what they want. As such, there is significant benefit to picking vim-airline over assigning your own statusline from component functions. It already works out of the box. The defaults are sensible and useful. And best of all, there&rsquo;s virtually no speed impact. Sure, you could go to the effort to benchmark the precise time it takes for vim to render with and without the plugin, and you would probably find a slight difference. But I haven&rsquo;t personally felt the impact of that lost time. Even better, I have definitely felt the impact of the benefits that have come from using vim-airline!</p> <a name=Brief-notes-on-plugins-I-do-use></a> <h3>Brief notes on plugins I do use</h3> <p>The majority of my plugins are either language specific, or too useful to let go. Chief among these is <a href=https://github.com/dense-analysis/ale>ale</a>, which is capable of providing asynchronous linting (via other installed programs) to any code buffer. I also am a big fan of <a href=https://github.com/ycm-core/YouCompleteMe>YouCompleteMe</a>. These two plugins require little to no configuration, and provide a huge amount of the features which many of those using vim as a code editor would otherwise miss. Seriously, I cannot recommend them enough, and if you don&rsquo;t already use them, give them a shot.</p> <p>My remaining plugins, for the most part, are features which extend capabilities vim already has. For example, <a href=https://github.com/preservim/nerdtree>NerdTree</a> makes the file exploration capability vim already had much more convenient to use, and provides several missing features such as the ability to actually operate on the whole files, not only edit individual files. There is also <a href=https://github.com/vim-airline/vim-airline>vim-airline</a>, which adds a fancy, pre-configured status bar to vim. This isn&rsquo;t strictly necessary, but being able to throw this plugin into my vimrc for almost no cost is excellent. The plugin doesn&rsquo;t impact either vim&rsquo;s performance or my personal time to either configure or poorly reimplement, which is that much more of a win for vim-airline.</p> <a name=Plugins-I-don-27-t-use-but-would></a> <h3>Plugins I don&rsquo;t use but would</h3> <a name=vimwiki></a> <h4>vimwiki</h4> <p><a href=https://github.com/vimwiki/vimwiki>vimwiki</a> looks extremely useful for a variety of reasons. Having a portable, in-project solution for documentation would be excellent, and this doubles as a great place to take personal and/or temporary notes for any particular purpose. The use of a mark-up syntax means it is perfectly reasonable to write strictly Github syntax markdown, for example, and easily compile that to a pdf or other accessible format on just about any system.</p> <p>The only reason I don&rsquo;t use the plugin is that I don&rsquo;t have an immediate personal need for it, though I may make one up just to try it pretty soon.</p> <a name=My-TODO-list-for-vim></a> <h3>My TODO list for vim</h3> <a name=Sessions></a> <h4>Sessions</h4> <p>One of the cooler features I&rsquo;ve seen offered by vim is the ability to create sessions, where all the objects in the environment (plugins, variables, open files, and more) are saved into a .session file which can be opened to restore the user to the state their vim session was in previously.</p> <p>I first heard about sessions when a friend sent me <a href=https://bocoup.com/blog/sessions-the-vim-feature-you-probably-arent-using>this article</a>, and Adam Sontag here goes over the most important capabilities of sessions, which aren&rsquo;t much more than I&rsquo;ve already described.</p> <p>My problem with sessions is about as surface-level as it gets, though: I forget to use them. Routinely. I&rsquo;ll have my environment set up for development on a rust or python project, work for a few hours, and then <code>:wq</code> without first saving the session information with :mks.</p> <p>What I&rsquo;d change is to have automatically saved and restored sessions for files I open. For example, if I were to open <code>pyproject/foo.py</code>, and there is a session file in the same directory as foo.py which was applied to foo.py, that session should be automatically restored. Seems simple enough, right? I haven&rsquo;t gotten around to making this change, however, and I haven&rsquo;t seen a plugin that can do this for me. It is worth noting that Adam Sontag referenced <a href=https://github.com/xolox/vim-session>vim-session</a>, which probably could get the job done with some tweaking.</p> <a name=Folding></a> <h4>Folding</h4> <p>I haven&rsquo;t found myself needing to use folding just yet, in any particular code base I&rsquo;ve worked in. Generally, if there is a function I&rsquo;m not currently working on or using, it simply isn&rsquo;t on the screen. If I need to see another function, I don&rsquo;t want to deal with opening the fold, I want to jump to the definition and see what working with immediately. When I used folds for a short while, these were the weaknesses I noticed which made me turn them off again. However, it may be reasonable to start using them again if the folds could automatically open and close under specific conditions. For example, if I were to jump to the definition of a function which is currently folded, it should open. Then, when I move away from that function, it should re-fold. As yet, I am not aware of any functionality to do this.</p> <a name=Tags></a> <h4>Tags</h4> <p>Tags, as I understand them, are a way to mark parts of a file as places which can be jumped to and from on the fly. Since this sounds like a helpful, speedy way to navigate complex buffers, especially those of code bases which I am currently learning, I might like to learn how to use vim&rsquo;s tagging functions.</p> <a name=That-27-s-vim-21-></a> <h3>That&rsquo;s vim!</h3> <p>Here&rsquo;s hoping you found a useful setting or plugin to try out, in reading this. If you know of any interesting and/or useful vim plugins or settings, send them my way and I&rsquo;ll give them a shot, and maybe add them to my list.</p> </article> <footer> <p>Licensed under <a href=/LICENSE.txt>GPLv3</a>.</p> <p> Code on <a href=https://github.com/gregdan3/gregdan3.github.io>my GitHub</a>. </p> </footer> </body> </html> 