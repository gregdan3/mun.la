<!DOCTYPE html><html lang=en-US> <head><meta charset=UTF-8><meta name=viewport content="width=device-width, height=device-height, user-scalable=yes, initial-scale=1.0"><meta name=date content=2020-02-20><meta property=og:title content="gregsite - Writing Code in LaTeX"><meta property=og:type content=website><meta property=og:url content=https://gregdan3.github.io/blog/writing-code-in-latex.md><meta property=og:image content=/avatar.jpg><meta property=og:locale content=en_US><meta property=og:site_name content=gregsite><meta property=og:description content="gregsite, read because it's free"><title>gregsite - Writing Code in LaTeX</title><link href=https://gregdan3.github.io/ rel=canonical><link href=/style.css rel=stylesheet type=text/css><link href=/favicon.ico rel=icon type=image/png></head> <body> <header> <a href=/ style="border-bottom: none"><img src=/avatar.jpg alt="gregdan3's avatar"></a> <h2><a href=/ >gregdan3</a></h2> <h3>Writing Code in LaTeX</h3> </header> <nav> <a href=/ >Home</a> <a href=/blog/ >Blogzone</a> <a href=/toki-pona/ >Toki Pona</a> </nav> <article> <p>This needs an update. I use <code>pygments</code> these days, which is even better!</p> <p>For writing LaTeX docs, I use <code>listings</code> over <code>algorithmic</code> or any other algorithm writing package for LaTeX. It’s more convenient to handle syntax and whitespace when writing another language in-line. The usual packages use their own functions to handle whitespace, and everything else; writing another language in-line will render exactly what you type.</p> <h1 id=algorithmic-for-latex>Algorithmic for LaTeX</h1> <p>I often see the algorithmic package recommended for demonstrating algorithms inside of LaTeX documents.</p> <p>Like many LaTeX packages, this comes with its own <a href=http://muug.ca/mirror/ctan/macros/latex/contrib/algorithms/algorithms.pdf>sizable set of docs</a> made up of a large quantity of commands which I might expect to exist already, but the exact syntax for which are anywhere between mildly frustrating and utterly arcane.</p> <p>As a less-than-optimal idea of what this might look like in practice, here’s a short (and possibly incorrect) algorithm I drafted which takes in a binary tree of integers and a sum, checking for a contiguous, non-backtracking path from any node to another (so only between parent and child nodes, no siblings) for which all the integers sum to the given value.</p> {% highlight latex %} <p>{% endhighlight %}</p> <p>As a side note, yes, it is necessary (or at least, it is necessary in my environment) to <code>\begin{algorithm}</code>, then <code>\begin{algorithmic}</code>. I have no idea why this is, and better yet, I often see algorithms written like this but without the outer algorithm block</p> <p>For reference, here’s a rendering of the above example: <img src=/assets/simplify-LaTeX/algorithmic-rendered.png alt=rendered-find-sum-in-tree></p> <p>More to the point: frankly, I wrote only three algorithms in this fashion. It is certainly convenient to include a dedicated comment syntax, so I can explain my reasoning as I step through an algorithm.</p> <p>And it is nice that I can include arbitrary syntax and terminology, as opposed to being locked exclusively into the provided syntax; as I recall, <code>algorithmicx</code> does this to a severe degree, and I abandoned using that package near immediately for this reason.</p> <p>But my single biggest gripe with the process has to do with organization. Just about every language has an expectation of how it should be organized in order to most clearly convey the flow of the program. Some languages, like Python, make whitespace an obligate component for designating how code behaves. At the least this is important. But nearly all the packages I found for writing LaTeX algorithms would outright refuse to observe my whitespace when rendering, and would instead force the use of their own provided functions for organizing code.</p> <p>I fought with these functions for one or two hours each time I wanted to write an algorithm like this.</p> <p>In all, the result algorithmic produces is not <em>that</em> bad, and the writing process is similarly not <em>that</em> bad. But I could not stand having to continually reference the docs for this process to determine whether or not I was correctly using the syntax. I’m not writing LaTeX to learn a new programming language, I’m writing it to type-set my documents and assignments in a more convenient fashion. Further, I couldn’t continue to waste time on setting my functions so that they appeared correctly on the page visually, even long after I had correctly written out the algorithm. This may well have been the breaking point for me.</p> <p>And so, shortly after dealing with this process for the third time, I decided to seek out a different solution for writing out algorithms in LaTeX. Preferably, I would like it to be as close to some existing language as possible, while still being excusably “pseudo-code.” In this case, the gold standard would be to write Python in-line, since Python is regularly deemed “pseudo-code brought to life.”</p> <h3 id=the-solution-i-found>The solution I found</h3> <p>Inside of the <code>texlive-science</code> collection of packages, there exists a package called <code>listings</code>. This package supports syntax highlighting for a large number of programming languages. Now, I can write the code I already wanted to write in a language I’m familiar with, without the extra cognitive load of converting from one syntax to another.</p> <p>And here’s what it looks like to use:</p> {% highlight latex %} <p>{% endhighlight %}</p> <p>This is much more comfy. Now, I can still write algorithms in my LaTeX documents, but I can simply in-line Python code to do so. Here’s the rendered result:</p> <figure> <img src=/assets/simplify-LaTeX/python-latex.png alt><figcaption>python-in-latex</figcaption> </figure> <p>In this case, all Python keywords are automatically highlighted, which I can use to my advantage when writing out an algorithm, such as I’ve done here with if/elif/else.</p> <p>Nothing prevents me from writing invalid Python code, so I can choose to write “true” pseudo-code in this block, and lstlisting will still honor my code organization and syntax. This is one of the big winners, because now I can use whitespace to organize my code how I expect it to be organized, without my package choice or LaTeX itself disagreeing with me on it!</p> <p>Most importantly, I can cap this off at either end with <code>\begin{lstlisting}</code> and then <code>\end{lstlisting}</code> and no further work is required.</p> <p>My only complaints are about the cleanliness of the render. It is likely possible to change the used font, font spacing, and other details of the rendering process within this block; I hadn’t looked for a solution to this problem just yet. But, for how simple it is to use, I’ll gladly concede these flaws to continue using <code>listings</code>.</p> </article> <footer> <p>Licensed under <a href=/LICENSE.txt>GPLv3</a>.</p> <p> Code on <a href=https://github.com/gregdan3/gregdan3.github.io>my GitHub</a>. </p> </footer> <script data-goatcounter=https://gregdan3.goatcounter.com/count async src=//gc.zgo.at/count.js></script> </body> </html> 